<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hoeken's Anchor Alarm</title>
  <link rel="apple-touch-icon" sizes="180x180" href="favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicons/favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">

  <link rel="preload" href="icons/anchor.png" as="image">
  <link rel="preload" href="icons/crosshair.png" as="image">

  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="leaflet/leaflet.css" />
  <script src="jquery-3.7.1.min.js"></script>
  <script src="leaflet/leaflet.js"></script>
  <script src="leaflet/leaflet.BoatMarker.js"></script>
  <script src="leaflet/leaflet.hotline.js"></script>
  <script src="leaflet/leaflet.textpath.js"></script>
</head>

<body>
  <div id="map_container">
    <div id="map"></div>
    <div id="map_toggle">
      <div id='anchorDown'>
        <button id='raiseAnchor'>Raise Anchor</button>
      </div>
      <div id='anchorUp'>
        <button id='dropAnchor'>Drop Anchor</button><br />
      </div>
      <div id='radiusControl'>
        <button id='decreaseRadius'> - </button>&nbsp;
        <button id='setRadius'><span id='radius'>0</span>m</button>&nbsp;
        <button id='increaseRadius'> + </button>
      </div>
    </div>
    <script>

      let _currentCoordinates;
      let _anchorCoordinates;
      let _filterRadius = 500;
      let _mmsi;
      let _maxRadius = 50;
      let _vessels = {};
      let _vesselTracks = {};

      let _twa = false;

      let _boatLOA = 0;
      let _boatBeam = 0;
      let _boatAnchorRollerHeight = 0;
      let _gpsBowYDistance = 0;
      let _gpsBowXDistance = 0;
      let _aisShipType = 0;
      let _tideDelta = 0;

      let _isAnchored = false;
      let _waitingForTheDrop = false;

      let myBoatMarker;
      let crosshairMarker;
      let gpsAntennaMarker;
      let anchorMarker;
      let anchorRadiusCircle;

      let map;

      let anchorIcon = L.icon({
        iconUrl: 'icons/anchor.png',
        iconSize: [24, 24], // size of the icon
        iconAnchor: [12, 12], // point of the icon which will correspond to marker's location
      });

      let crosshairIcon = L.icon({
        iconUrl: 'icons/crosshair.png',
        iconSize: [24, 24], // size of the icon
        iconAnchor: [12, 12], // point of the icon which will correspond to marker's location
      });

      crosshairMarker = L.marker({
        icon: crosshairIcon
      });

      let gpsAntennaIcon = L.icon({
        iconUrl: 'icons/antenna.svg',
        iconSize: [25, 25], // size of the icon
        iconAnchor: [13, 25], // point of the icon which will correspond to marker's location
      });

      let anchorLine;
      let anchorLineAngle;

      let urlParams = new URLSearchParams(window.location.search);

      satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
        maxZoom: 23,
        maxNativeZoom: 17,      // Highest zoom level Esri has real imagery for
        tileSize: 256,
        noWrap: true,
        keepBuffer: 5
      });

      osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Map data from OpenStreetMap (OSM)',
        maxZoom: 23
      });

      let baseMaps = {
        "OpenStreetMap": osmLayer,
        "Satellite": satelliteLayer
      };

      // Define the info box control
      const InfoBoxControl = L.Control.extend({
        options: {
          position: 'bottomright' // 'topleft', 'topright', 'bottomleft', 'bottomright'
        },

        onAdd: function (map) {
          // Create a container div with a class
          const container = L.DomUtil.create('div', 'info leaflet-bar');

          // Prevent events from being propagated to the map
          L.DomEvent.disableClickPropagation(container);

          container.innerHTML = `
              <table>
                <tr>
                  <th>Depth:</th>
                  <td><span title="Below Surface" id='belowSurface'>~</span> / <span title="Below Keel" id='belowKeel'>~</span></td>
                </tr>
                <tr>
                  <th>Wind:</th>
                  <td><span title="Wind Speed" id='awsValue'>~</span> / <span title="Wind Direction" id='awaValue'>~</span></td>
                </tr>
                <tr>
                  <th>Status:</th>
                  <td><span id='pluginStatus'>Loading</span></td>
                </tr>
              </table>
          `;

          container.id = "infoUI";

          return container;
        }
      });

      // Define the info box control
      const ScopeBoxControl = L.Control.extend({
        options: {
          position: 'bottomright' // 'topleft', 'topright', 'bottomleft', 'bottomright'
        },

        onAdd: function (map) {
          // Create a container div with a class
          const container = L.DomUtil.create('div', 'scope leaflet-bar');

          // Prevent events from being propagated to the map
          L.DomEvent.disableClickPropagation(container);

          container.id = "scopeUI";
          container.innerHTML = `
              <table>
                <tr>
                  <th>Water&nbsp;Depth</th>
                  <td><span id='scopeDepth'>~</span></td>
                </tr>
                <tr>
                  <th>Bow&nbsp;Height</th>
                  <td>+ <span id='bowHeight'>~</span></td>
                </tr>
                <tr>
                  <th>Tidal&nbsp;Rise</th>
                  <td>+ <span id='tideDelta'>~</span></td>
                </tr>
                <tr>
                  <th>Total</th>
                  <td>= <span id='scopeTotal'>~</span></td>
                </tr>
                <tr>
                  <th colspan="2">&nbsp;</th>
                </tr>
                <tr>
                  <th>7:1&nbspScope</th>
                  <td><span id='scope7to1'>~</span></td>
                </tr>
                <tr>
                  <th>5:1&nbspScope</th>
                  <td><span id='scope5to1'>~</span></td>
                </tr>
                <tr>
                  <th>4:1&nbspScope</th>
                  <td><span id='scope4to1'>~</span></td>
                </tr>
                <tr>
                  <th>3:1&nbspScope</th>
                  <td><span id='scope3to1'>~</span></td>
                </tr>
              </table>
          `;

          return container;
        }
      });

      //this is our initial data lookup call.  Needs to happen first.
      $.get('/signalk/v1/api/vessels/self', (data) => {
        _mmsi = data.mmsi;

        //anchor distance guess...
        let anchorDistanceGuess = 0;

        //a couple different depths
        let belowKeel;
        let belowSurface;
        if (typeof data.environment.depth?.belowKeel?.value !== "undefined")
          belowKeel = data.environment.depth.belowKeel.value;
        if (typeof data.environment.depth?.belowSurface?.value !== "undefined")
          belowSurface = data.environment.depth.belowSurface.value;
        updateDepthUI(belowSurface, belowKeel);

        //wind info.
        if (typeof data.environment.wind?.directionTrue?.value !== "undefined") {
          _twa = rad2deg(data.environment.wind.directionTrue.value);
          updateWindAngleUI(_twa);
        }
        if (typeof data.environment.wind?.speedApparent?.value !== "undefined")
          updateWindSpeedUI(data.environment.wind.speedApparent.value);

        //save our parameters for boat size + gps position
        if (typeof data.design?.length?.value !== "undefined")
          _boatLOA = parseFloat(data.design.length.value.overall);
        if (typeof data.design?.beam?.value !== "undefined")
          _boatBeam = parseFloat(data.design.beam?.value);
        if (typeof data.design?.bowAnchorRollerHeight?.value !== "undefined")
          _boatAnchorRollerHeight = parseFloat(data.design.bowAnchorRollerHeight?.value);
        if (typeof data.sensors?.gps?.fromBow?.value !== "undefined")
          _gpsBowYDistance = data.sensors.gps.fromBow.value;
        if (typeof data.sensors?.gps?.fromCenter?.value !== "undefined")
          _gpsBowXDistance = data.sensors.gps.fromCenter.value;
        if (typeof data.design?.aisShipType?.value?.id !== "undefined")
          _aisShipType = data.design.aisShipType.value.id;

        //check our tide data
        if (typeof data.environment.tide !== undefined) {
          let currentTide = estimateTideHeightSmooth(data.environment.tide.timeLow.value, data.environment.tide.heightLow.value, data.environment.tide.timeHigh.value, data.environment.tide.heightHigh.value);
          _tideDelta = data.environment.tide.heightHigh.value - currentTide;
        }

        //try to guess where to put the anchor.
        anchorDistanceGuess = calculateScope(5, belowSurface);

        //our radius defaults.
        _maxRadius = anchorDistanceGuess;
        _maxRadius += calculateVectorDistance(_gpsBowXDistance, _gpsBowYDistance);
        _maxRadius *= 1.5;
        _maxRadius = Math.round(_maxRadius / 5) * 5; //multiples of 5
        _maxRadius = Math.max(0, _maxRadius);
        _maxRadius = Math.min(200, _maxRadius);

        data = data.navigation;
        _currentCoordinates = L.latLng(data.position.value.latitude, data.position.value.longitude);

        //init our map
        map = L.map('map', {
          zoomControl: false,
        }).setView(_currentCoordinates, 5);

        //default to satellite
        satelliteLayer.addTo(map);

        //add scale control
        L.control.scale({
          position: 'topleft' // Options: 'topleft', 'topright', 'bottomleft', 'bottomright'
        }).addTo(map);

        //add zoom control
        L.control.zoom({
          position: 'topright' // Options: 'topleft', 'topright', 'bottomleft', 'bottomright'
        }).addTo(map);

        //add layer control
        let layerControl = L.control.layers(baseMaps, {}, {
          position: 'topright' // Options: 'topleft', 'topright', 'bottomleft', 'bottomright'
        }).addTo(map);

        // Infobox for status
        const infoBox = new InfoBoxControl();
        map.addControl(infoBox);

        // ScopeBox for scope suggestion
        const scopeBox = new ScopeBoxControl();
        map.addControl(scopeBox);

        //load up our heading.
        let heading = data.headingTrue?.value;
        if (heading) {
          heading = rad2deg(heading);
        } else {
          heading = 0;
        }
        _heading = heading;

        //calculate the x offset from the left side, not center
        let xOffset = _boatBeam / 2 + _gpsBowXDistance;

        //marker for our boat
        myBoatMarker = new L.BoatMarker(_currentCoordinates, {
          beam: _boatBeam,
          loa: _boatLOA,
          gpsOffset: { x: xOffset, y: _gpsBowYDistance },
          heading: heading,
          icon: getShipTypeIcon(_aisShipType, _boatLOA / _boatBeam)
        }).addTo(map)

        //marker for our boat's antenna
        gpsAntennaMarker = L.marker(_currentCoordinates, {
          icon: gpsAntennaIcon
        }).addTo(map);

        //our radius
        anchorRadiusCircle = L.circle(map.getCenter(), _maxRadius, { color: 'green' });
        anchorRadiusCircle.addTo(map)
        uiSetRadius(_maxRadius)

        _anchorCoordinates = map.getCenter();

        anchorLine = L.polyline([_currentCoordinates, _anchorCoordinates], {
          color: 'grey',
          weight: 2
        }).addTo(map);

        anchorLineAngle = L.polyline([_currentCoordinates, _anchorCoordinates], {
          color: 'grey',
          weight: 0
        }).addTo(map);

        if ((data.anchor) && (data.anchor.position) && (data.anchor.position.value)) {
          let anchorPosition = data.anchor.position.value;
          _anchorCoordinates = L.latLng(anchorPosition.latitude, anchorPosition.longitude);
          let radius = parseInt(data.anchor.maxRadius.value);
          dropAnchor(_anchorCoordinates, radius);
        } else {
          let bowPos = calculateBowCoordinates(_currentCoordinates, heading, _gpsBowXDistance, _gpsBowYDistance);
          let anchorPositionGuess = calculateDestinationPoint(bowPos.lat, bowPos.lng, heading, anchorDistanceGuess);
          _anchorCoordinates = L.latLng(anchorPositionGuess.latitude, anchorPositionGuess.longitude);
          raiseAnchor();
        }

        updateAnchorLine(_currentCoordinates, _anchorCoordinates);

        //zoom baby zoom.
        map.fitBounds(anchorRadiusCircle.getBounds());

        //load up all the other vessels.
        $.get(`/signalk/v1/api/tracks?radius=${_filterRadius}`, (tracks) => {
          const mmsiRegex = /urn:mrn:imo:mmsi:(\d+)$/;
          for (uri in tracks) {
            const match = uri.match(mmsiRegex);
            if (match) {
              let mmsi = match[1];
              let data = tracks[uri];

              if (data.coordinates[0].length) {

                let history = data.coordinates[0];

                let points = [];
                let i = 0;
                for (let position of history) {
                  let lat = position[1];
                  let lon = position[0];
                  let distance = calculateDistance(_currentCoordinates.lat, _currentCoordinates.lng, lat, lon);

                  if (distance < _filterRadius) {
                    points.push([lat, lon, i]);
                    i++;
                  }
                }

                _vesselTracks[mmsi] = L.hotline(points, {
                  color: 'red',
                  weight: 1,
                  min: 0,
                  max: points.length,
                  palette: { 0.0: 'red', 0.5: 'yellow', 1.0: 'green' },
                  outlineWidth: 0,
                  text: ''
                }).addTo(map);
              }
            }
          }
        });

        //start our interval updater
        setInterval(intervalUpdate, 1000);
      });


      //live update of data 
      function intervalUpdate() {

        //update our position
        $.get('/signalk/v1/api/vessels/self/navigation', (data) => {
          _currentCoordinates = L.latLng(data.position.value.latitude, data.position.value.longitude);

          //load our heading value
          let heading = data.headingTrue?.value;
          if (heading) {
            heading = rad2deg(heading);
          } else {
            heading = 0;
          }
          _heading = heading;

          //update our markers
          myBoatMarker.setLatLng(_currentCoordinates);
          myBoatMarker.setHeading(heading);
          gpsAntennaMarker.setLatLng(_currentCoordinates);

          //add to our scribble
          if (_vesselTracks[_mmsi]) {
            _vesselTracks[_mmsi].addLatLng([_currentCoordinates.lat, _currentCoordinates.lng, _vesselTracks[_mmsi].getLatLngs().length]);
            _vesselTracks[_mmsi].options.max++;
          }

          //redraw our anchor line
          updateAnchorLine(_currentCoordinates, _anchorCoordinates);
        });

        //what is our current status?
        $.get('/signalk/v1/api/vessels/self/notifications/navigation/anchor', (alarm) => {
          $('#pluginStatus').html(alarm.value.message);
          $('#pluginStatus').removeClass();
          if (alarm.value.message != 'Off')
            $('#pluginStatus').addClass(alarm.value.state);
        });

        //update our depth
        $.get('/signalk/v1/api/vessels/self/environment/depth', (data) => {
          let belowSurface;
          let belowKeel;
          if (data.hasOwnProperty('belowSurface'))
            belowSurface = data.belowSurface.value;
          if (data.hasOwnProperty('belowKeel'))
            belowKeel = data.belowKeel.value;

          updateDepthUI(belowSurface, belowKeel);
          updateScopeUI(belowSurface);
        }).fail((response) => {
          $('#belowSurface').html("~");
          $('#belowKeel').html("~");
        });

        //update wind speed.
        $.get('/signalk/v1/api/vessels/self/environment/wind/speedApparent/value', (speedApparent) => {
          updateWindSpeedUI(speedApparent);
        }).fail((response) => {
          $('#awsValue').html("~");
        });

        //update wind angle.
        $.get('/signalk/v1/api/vessels/self/environment/wind/directionTrue/value', (directionTrue) => {
          _twa = rad2deg(directionTrue);
          updateWindAngleUI(directionTrue);
        }).fail((response) => {
          $('#awaValue').html("~");
        });

        //update our watch status
        $.get('/signalk/v1/api/vessels/self/navigation/anchor', (anchorStatus) => {
          if (!_waitingForTheDrop) {
            if (anchorStatus.state.value === "on") {
              _maxRadius = anchorStatus.maxRadius.value;
              _anchorCoordinates = L.latLng(anchorStatus.position.value.latitude, anchorStatus.position.value.longitude);
              uiSetRadius(_maxRadius);

              //switch to anchored?
              if (!_isAnchored) {
                dropAnchor(_anchorCoordinates, _maxRadius);
              }
            }
            //switch off anchored?
            else if (_isAnchored) {
              raiseAnchor();
            }
          }
        });

        //update any other vessels and their tracks.
        $.get('/signalk/v1/api/vessels', (vessels) => {
          let detectedVessels = [];
          for (let key in vessels) {
            let vessel = vessels[key];
            if (vessel.mmsi == _mmsi) {
              continue;
            }
            if (!("navigation" in vessel) || !("position" in vessel.navigation)) {
              continue;
            }

            //try to figure out where they are pointing
            let vessel_heading = 0;
            //heading would be best.... but it doesnt show up in AIS very often
            if (typeof vessel.navigation?.headingTrue?.value !== "undefined")
              vessel_heading = rad2deg(vessel.navigation.headingTrue.value);
            //true wind angle looks the cleanest
            if (_twa !== false)
              vessel_heading = _twa;
            //COG works, but is really wonky.
            else if (typeof vessel.navigation?.courseOverGroundTrue?.value !== "undefined")
              vessel_heading = rad2deg(vessel.navigation.courseOverGroundTrue.value);

            //where are they?
            let position = vessel.navigation.position.value;
            let distance = calculateDistance(position.latitude, position.longitude, _currentCoordinates.lat, _currentCoordinates.lng);

            //only show vessels in our radius
            if (distance <= _filterRadius) {
              detectedVessels.push(vessel.mmsi);
              distance = Math.round(distance);

              //have we seen them already?
              if (vessel.mmsi in _vessels) {
                _vessels[vessel.mmsi].setLatLng([position.latitude, position.longitude]);
                _vessels[vessel.mmsi].setHeading(vessel_heading);
                _vessels[vessel.mmsi]._popup.setContent(`${vessel.name} at ${distance} meters`);
                _vessels[vessel.mmsi].gpsAntennaMarker.setLatLng([position.latitude, position.longitude]);

                //do we have a track for them?
                if (_vesselTracks[vessel.mmsi]) {
                  let lastPosition = _vesselTracks[vessel.mmsi].getLatLngs().at(-1);
                  if (lastPosition && (lastPosition.lat != position.latitude || lastPosition.lng != position.longitude)) {
                    _vesselTracks[vessel.mmsi].addLatLng([position.latitude, position.longitude, _vesselTracks[vessel.mmsi].options.max]);
                    _vesselTracks[vessel.mmsi].options.max++;
                  }
                }
                //nope, create their info
              } else {

                //default values
                let loa = 14;
                let beam = 4
                let aisShipType = 36;
                let gpsXOffset = 0;
                let gpsYOffset = 0;

                console.log(vessel.name);
                console.log(vessel.sensors.ais);

                //load them if we got them.
                if (typeof vessel.sensors.ais?.fromCenter?.value !== "undefined")
                  gpsXOffset = parseFloat(vessel.sensors.ais.fromCenter.value);
                if (typeof vessel.sensors.ais?.fromBow?.value !== "undefined")
                  gpsYOffset = parseFloat(vessel.sensors.ais.fromBow.value);
                if (typeof vessel.design?.length?.value !== "undefined")
                  loa = parseFloat(vessel.design.length.value.overall);
                if (typeof vessel.design?.beam?.value !== "undefined")
                  beam = parseFloat(vessel.design.beam.value);
                if (typeof vessel.design?.aisShipType?.value?.id !== "undefined")
                  aisShipType = vessel.design.aisShipType.value.id;

                //calculate the x offset from the left side, not center
                let xOffset = beam / 2 + _gpsBowXDistance;

                //create our boat marker
                _vessels[vessel.mmsi] = new L.BoatMarker([position.latitude, position.longitude], {
                  beam: beam,
                  loa: loa,
                  gpsOffset: { x: xOffset, y: gpsYOffset },
                  heading: vessel_heading,
                  icon: getShipTypeIcon(aisShipType, loa / beam)
                });
                _vessels[vessel.mmsi].addTo(map).bindPopup(`${vessel.name} at ${distance} meters`);

                //marker for our boat's antenna
                _vessels[vessel.mmsi].gpsAntennaMarker = L.marker([position.latitude, position.longitude], {
                  icon: gpsAntennaIcon
                }).addTo(map);
                _vessels[vessel.mmsi].gpsAntennaMarker.setLatLng([position.latitude, position.longitude]);

                //make sure we didnt load their track already.
                if (vessel.mmsi in _vesselTracks === false) {
                  _vesselTracks[vessel.mmsi] = L.hotline([[position.latitude, position.longitude, 0]], {
                    color: 'red',
                    weight: 1,
                    min: 0,
                    max: 1,
                    palette: { 0.0: 'red', 0.5: 'yellow', 1.0: 'green' },
                    outlineWidth: 0,
                    text: ''
                  }).addTo(map);
                }
              }
            }
          }
          for (let mmsi in _vessels) {
            if (!detectedVessels.includes(mmsi)) {
              map.removeLayer(_vessels[mmsi]);
              delete _vessels[mmsi];
              map.removeLayer(_vesselTracks[mmsi]);
              delete _vesselTracks[mmsi];
            }
          }
        });
      }

      $('#raiseAnchor').click(() => {
        let agree = confirm('Do you really want to disable your anchor alarm?');
        if (agree) {
          _waitingForTheDrop = true;
          raiseAnchor(); //better UI response outside.
          $.post('/plugins/hoekens-anchor-alarm/raiseAnchor', () => { }).fail((response) => {
          }).fail((response) => {
            if (response.status == 401)
              location.href = "/admin/#/login";
          }).always(() => {
            _waitingForTheDrop = false;
          });
        }
      });

      $('#dropAnchor').click(() => {
        //let mc = map.getCenter()
        let mc = crosshairMarker.getLatLng();
        _waitingForTheDrop = true;
        dropAnchor(mc, _maxRadius); //better UI response outside.
        let newPosition = { latitude: mc.lat, longitude: mc.lng };
        $.post('/plugins/hoekens-anchor-alarm/dropAnchor', { position: newPosition, radius: _maxRadius }, () => {
        }).fail((response) => {
          if (response.status == 401)
            location.href = "/admin/#/login";
        }).always(() => {
          _waitingForTheDrop = false;
        });
      });

      $('#setRadius').click(() => {
        let newRadius = parseInt(prompt('Enter Radius (m)', _maxRadius))
        if (newRadius <= 0)
          return;

        _maxRadius = newRadius;
        uiSetRadius(newRadius);

        if (_isAnchored) {
          _waitingForTheDrop = true;
          $.post('/plugins/hoekens-anchor-alarm/setRadius', { radius: newRadius })
            .fail((response) => {
              if (response.status == 401)
                location.href = "/admin/#/login";
            })
            .always(() => {
              _waitingForTheDrop = false;
            });
        }

      });

      $('#increaseRadius').click(() => {
        _maxRadius = parseInt(_maxRadius) + 5;
        uiSetRadius(_maxRadius);

        if (_isAnchored) {
          _waitingForTheDrop = true;
          $.post('/plugins/hoekens-anchor-alarm/setRadius', { radius: _maxRadius })
            .fail((response) => {
              if (response.status == 401)
                location.href = "/admin/#/login";
            })
            .always(() => {
              _waitingForTheDrop = false;
            });
        }
      });

      $('#decreaseRadius').click(() => {
        _maxRadius = parseInt(_maxRadius);
        if (_maxRadius <= 5)
          return;

        _maxRadius = _maxRadius - 5;
        uiSetRadius(_maxRadius)

        if (_isAnchored) {
          _waitingForTheDrop = true;
          $.post('/plugins/hoekens-anchor-alarm/setRadius', { radius: _maxRadius })
            .fail((response) => {
              if (response.status == 401)
                location.href = "/admin/#/login";
            })
            .always(() => {
              _waitingForTheDrop = false;
            });
        }
      });

      function uiSetRadius(radius) {
        $('#radius').html(radius);
        anchorRadiusCircle.setRadius(radius);
        uiSetRadiusColor()
      }

      function uiSetRadiusColor() {
        if (calculateDistance(anchorRadiusCircle.getLatLng().lat, anchorRadiusCircle.getLatLng().lng, myBoatMarker.getLatLng().lat, myBoatMarker.getLatLng().lng) > anchorRadiusCircle.getRadius())
          anchorRadiusCircle.setStyle({ 'color': 'red' })
        else if (_isAnchored)
          anchorRadiusCircle.setStyle({ 'color': 'green' })
        else
          anchorRadiusCircle.setStyle({ 'color': 'blue' })
      }

      function dropAnchor(position, radius) {
        $('#anchorDown').show();
        $('#anchorUp').hide();

        _anchorCoordinates = position;

        _isAnchored = true;

        $('#scopeUI').hide();
        $('#infoUI').show();

        _maxRadius = parseInt(radius);
        if (_maxRadius <= 0)
          _maxRadius = 20;

        map.removeLayer(crosshairMarker);

        anchorRadiusCircle.setLatLng(position);
        uiSetRadius(_maxRadius)

        anchorMarker = L.marker(position, {
          icon: anchorIcon
        }).addTo(map);
      }

      function raiseAnchor() {
        $('#anchorUp').show();
        $('#anchorDown').hide();

        _isAnchored = false;

        $('#infoUI').hide();
        $('#scopeUI').show();

        if (typeof anchorMarker != "undefined")
          map.removeLayer(anchorMarker);

        uiSetRadiusColor();

        crosshairMarker = L.marker(_anchorCoordinates, {
          icon: crosshairIcon,
          draggable: true
        }).addTo(map);

        crosshairMarker.on('drag', function (ev) {
          if (!_isAnchored) {
            _anchorCoordinates = crosshairMarker.getLatLng();
            updateAnchorLine(_currentCoordinates, _anchorCoordinates);
            anchorRadiusCircle.setLatLng(crosshairMarker.getLatLng());
            uiSetRadiusColor();
          }
        });

        anchorRadiusCircle.setLatLng(_anchorCoordinates);

        updateAnchorLine(_currentCoordinates, _anchorCoordinates);
      }

      function updateDepthUI(dbs, dbk) {
        let output;

        if (typeof dbs !== "undefined")
          dbs = Math.round(dbs * 10) / 10;
        else
          dbs = '~'

        if (typeof dbk !== "undefined")
          dbk = Math.round(dbk * 10) / 10;
        else
          dbk = '~'

        $('#belowSurface').html(`${dbs}m`);
        $('#belowKeel').html(`${dbk}m`);
      }

      function updateScopeUI(dbs) {

        let scope;

        let maxHeight = dbs;

        //the height of our bow roller.
        maxHeight += _boatAnchorRollerHeight;

        //the delta between now and high tide.
        maxHeight += _tideDelta;

        scope = calculateScope(7, dbs);
        scope = scope.toFixed(1);
        $('#scope7to1').html(`${scope}m`);

        scope = calculateScope(5, dbs);
        scope = scope.toFixed(1);
        $('#scope5to1').html(`${scope}m`);

        scope = calculateScope(4, dbs);
        scope = scope.toFixed(1);
        $('#scope4to1').html(`${scope}m`);

        scope = calculateScope(3, dbs);
        scope = scope.toFixed(1);
        $('#scope3to1').html(`${scope}m`);

        let dbsDisplay = dbs.toFixed(1);
        $('#scopeDepth').html(`${dbsDisplay}m`);

        let bowHeightDisplay = _boatAnchorRollerHeight.toFixed(1);
        $('#bowHeight').html(`${bowHeightDisplay}m`);

        let tideDelta = _tideDelta.toFixed(1);
        $('#tideDelta').html(`${tideDelta}m`);

        maxHeight = maxHeight.toFixed(1);
        $('#scopeTotal').html(`${maxHeight}m`);

      }

      function calculateScope(scope, dbs) {

        //start with depth
        let maxHeight = dbs;

        //the height of our bow roller.
        maxHeight += _boatAnchorRollerHeight;

        //the delta between now and high tide.
        maxHeight += _tideDelta;

        //okay, send it back.
        let total = maxHeight * scope;

        return total;
      }

      function updateWindSpeedUI(speedApparent) {
        if (typeof speedApparent !== "undefined") {
          let kts = Math.round(speedApparent * 1.94384);
          $('#awsValue').html(`${kts}kts`);
        } else {
          $('#awsValue').html('~');
        }
      }

      function updateWindAngleUI(directionTrue) {
        if (typeof directionTrue !== "undefined") {
          let angle = Math.round(rad2deg(directionTrue));
          if (angle < 0)
            angle = 360 - angle;
          $('#awaValue').html(`${angle}°`);
        } else {
          $('#awaValue').html('~');
        }
      }

      function updateAnchorLine(current, anchor) {

        let _bowCoordinates = calculateBowCoordinates(current, _heading, _gpsBowXDistance, _gpsBowYDistance);

        anchorLine.setLatLngs([_bowCoordinates, anchor]);
        anchorLineAngle.setLatLngs([_bowCoordinates, anchor]); // this duplicate on is so we can have 2 text labels

        //this will fail if you're anchored exactly on the equator, lol.
        let flip = false;
        if (_bowCoordinates.lng > anchor.lng)
          flip = true;

        let distance = calculateDistance(_bowCoordinates.lat, _bowCoordinates.lng, anchor.lat, anchor.lng);
        distance = Math.round(distance * 10) / 10;

        anchorLine.setText("");
        anchorLine.setText(`${distance}m`, {
          orientation: flip ? 'flip' : 0,
          offset: 12,
          center: true,
          attributes: {
            class: "anchorLineLabel"
          }
        });

        const bearing = Math.round(calculateBearing(_bowCoordinates.lat, _bowCoordinates.lng, anchor.lat, anchor.lng));

        anchorLineAngle.setText("");
        anchorLineAngle.setText(`${bearing}°`, {
          orientation: flip ? 'flip' : 0,
          offset: -3,
          center: true,
          attributes: {
            class: "anchorLineLabel"
          }
        });

      }

      function getShipTypeIcon(aisShipType, aspectRatio) {
        let icon = "icons/ships/png/default.png";

        aisShipType = parseInt(aisShipType);

        // console.log(aisShipType);
        // console.log(aspectRatio);

        switch (aisShipType) {
          case 20: // Wing in ground (WIG), all ships of this type
          case 21: // Wing in ground (WIG), Hazardous category A
          case 22: // Wing in ground (WIG), Hazardous category B
          case 23: // Wing in ground (WIG), Hazardous category C
          case 24: // Wing in ground (WIG), Hazardous category D
          case 25: // Wing in ground (WIG), Reserved for future use
          case 26: // Wing in ground (WIG), Reserved for future use
          case 27: // Wing in ground (WIG), Reserved for future use
          case 28: // Wing in ground (WIG), Reserved for future use
          case 29: // Wing in ground (WIG), Reserved for future use
            icon = "icons/ships/png/wing-in-ground.png";
            break;

          case 30: // Fishing
            icon = "icons/ships/png/fishing.png";
            break;

          case 31: // Towing
          case 32: // Towing: length exceeds 200m or breadth exceeds 25m
            icon = "icons/ships/png/towing.png";
            break;

          case 33: // Dredging or underwater ops
            icon = "icons/ships/png/dredging.png";
            break;

          case 34: // Diving ops
            icon = "icons/ships/png/diving.png";
            break;

          case 35: // Military ops
            icon = "icons/ships/png/military.png";
            break;

          case 36: // Sailing
            if (aspectRatio >= 2.5)
              icon = "icons/ships/png/sailboat.png";
            else
              icon = "icons/ships/png/catamaran.png"
            break;

          case 37: // Pleasure Craft
            icon = "icons/ships/png/pleasure.png";
            break;

          case 40: // High speed craft (HSC), all ships of this type
          case 41: // High speed craft (HSC), Hazardous category A
          case 42: // High speed craft (HSC), Hazardous category B
          case 43: // High speed craft (HSC), Hazardous category C
          case 44: // High speed craft (HSC), Hazardous category D
          case 45: // High speed craft (HSC), Reserved for future use
          case 46: // High speed craft (HSC), Reserved for future use
          case 47: // High speed craft (HSC), Reserved for future use
          case 48: // High speed craft (HSC), Reserved for future use
          case 49: // High speed craft (HSC), No additional information
            icon = "icons/ships/png/high-speed-craft.png";
            break;

          case 50: // Pilot Vessel
            icon = "icons/ships/png/pilot.png";
            break;

          case 51: // Search and Rescue vessel
            icon = "icons/ships/png/sar.png";
            break;

          case 52: // Tug
            icon = "icons/ships/png/tug.png";
            break;

          case 53: // Port Tender
            icon = "icons/ships/png/port-tender.png";
            break;

          case 54: // Anti-pollution equipment
            icon = "icons/ships/png/anti-pollution.png";
            break;

          case 55: // Law Enforcement
            icon = "icons/ships/png/police.png";
            break;

          case 58: // Medical Transport
            icon = "icons/ships/png/medical.png";
            break;

          case 59: // Noncombatant ship according to RR Resolution No. 18
            icon = "icons/ships/png/noncombatant.png";
            break;

          case 60: // Passenger, all ships of this type
          case 61: // Passenger, Hazardous category A
          case 62: // Passenger, Hazardous category B
          case 63: // Passenger, Hazardous category C
          case 64: // Passenger, Hazardous category D
          case 65: // Passenger, Reserved for future use
          case 66: // Passenger, Reserved for future use
          case 67: // Passenger, Reserved for future use
          case 68: // Passenger, Reserved for future use
          case 69: // Passenger, No additional information
            icon = "icons/ships/png/passenger.png";
            break;

          case 70: // Cargo, all ships of this type
          case 71: // Cargo, Hazardous category A
          case 72: // Cargo, Hazardous category B
          case 73: // Cargo, Hazardous category C
          case 74: // Cargo, Hazardous category D
          case 75: // Cargo, Reserved for future use
          case 76: // Cargo, Reserved for future use
          case 77: // Cargo, Reserved for future use
          case 78: // Cargo, Reserved for future use
          case 79: // Cargo, No additional information
            icon = "icons/ships/png/cargo.png";
            break;

          case 80: // Tanker, all ships of this type
          case 81: // Tanker, Hazardous category A
          case 82: // Tanker, Hazardous category B
          case 83: // Tanker, Hazardous category C
          case 84: // Tanker, Hazardous category D
          case 85: // Tanker, Reserved for future use
          case 86: // Tanker, Reserved for future use
          case 87: // Tanker, Reserved for future use
          case 88: // Tanker, Reserved for future use
          case 89: // Tanker, No additional information
            icon = "icons/ships/png/tanker.png";
            break;

          case 90: // Other Type, all ships of this type
          case 91: // Other Type, Hazardous category A
          case 92: // Other Type, Hazardous category B
          case 93: // Other Type, Hazardous category C
          case 94: // Other Type, Hazardous category D
          case 95: // Other Type, Reserved for future use
          case 96: // Other Type, Reserved for future use
          case 97: // Other Type, Reserved for future use
          case 98: // Other Type, Reserved for future use
          case 99: // Other Type, no additional information
            icon = "icons/ships/png/other.png";
            break;

          // 0 	Not available (default)
          // 1-19 	Reserved for future use
          // 38 	Reserved
          // 39 	Reserved
          // 56 	Spare - Local Vessel
          // 57 	Spare - Local Vessel
          default:
            break;
        }

        return icon;
      }

      function calculateBowCoordinates(current, heading, xOffset, yOffset) {
        //first do our Y along our heading.
        let bc = calculateDestinationPoint(current.lat, current.lng, heading, yOffset);

        //then do our X at 90 degrees.
        if (xOffset != 0) {
          let _heading2 = heading;
          if (_gpsBowXDistance > 0)
            _heading2 = heading + 90;
          else if (xOffset < 0)
            _heading2 = heading - 90;
          _heading2 = normalizeAngle(_heading2);
          bc = calculateDestinationPoint(bc.latitude, bc.longitude, _heading2, xOffset);
        }

        //okay use the new bow coordinates
        return L.latLng(bc.latitude, bc.longitude);
      }

      function calculateDistance(lat1, lon1, lat2, lon2) {
        let R = 6371000; // Radius of the earth in m
        let dLat = deg2rad(lat2 - lat1);  // deg2rad below
        let dLon = deg2rad(lon2 - lon1);
        let a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2)
          ;
        let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        let d = R * c; // Distance in km
        return d;
      }

      function deg2rad(deg) {
        return deg * (Math.PI / 180)
      }

      // Convert radians to degrees
      function rad2deg(radians) {
        return radians * 180 / Math.PI;
      }

      function calculateBearing(lat1, lon1, lat2, lon2) {
        // Convert latitude and longitude from degrees to radians
        var θa = deg2rad(lat1);
        var θb = deg2rad(lat2);
        var ΔL = deg2rad(lon2 - lon1);

        // Calculate X and Y using the provided formulas
        var X = Math.cos(θb) * Math.sin(ΔL);
        var Y = Math.cos(θa) * Math.sin(θb) - Math.sin(θa) * Math.cos(θb) * Math.cos(ΔL);

        // Calculate the initial bearing (β) in radians
        var β = Math.atan2(X, Y);

        // Convert the bearing from radians to degrees
        var bearing = rad2deg(β);

        // Normalize the bearing to be between 0° and 360°
        bearing = (bearing + 360) % 360;

        return bearing;
      }

      /**
       * Calculates the destination point given starting latitude and longitude,
       * bearing, and distance using the haversine formula.
       *
       * @param {number} lat1 - Starting latitude in degrees.
       * @param {number} lon1 - Starting longitude in degrees.
       * @param {number} bearing - Bearing in degrees (clockwise from north).
       * @param {number} distance - Distance to travel from the starting point in meters.
       * @returns {{ latitude: number, longitude: number }} - The destination latitude and longitude.
       */
      function calculateDestinationPoint(lat1, lon1, bearing, distance) {

        //console.log(`lat: ${lat1}, lon: ${lon1}, bearing: ${bearing}, distance: ${distance}`);
        const R = 6371e3; // Earth's radius in meters

        // Convert input values to radians
        const φ1 = (lat1 * Math.PI) / 180;
        const λ1 = (lon1 * Math.PI) / 180;
        const θ = (bearing * Math.PI) / 180;
        const δ = distance / R; // Angular distance in radians

        // Calculate destination coordinates
        const sinφ1 = Math.sin(φ1);
        const cosφ1 = Math.cos(φ1);
        const sinδ = Math.sin(δ);
        const cosδ = Math.cos(δ);
        const sinθ = Math.sin(θ);
        const cosθ = Math.cos(θ);

        const sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * cosθ;
        const φ2 = Math.asin(sinφ2);

        const y = sinθ * sinδ * cosφ1;
        const x = cosδ - sinφ1 * sinφ2;
        const λ2 = λ1 + Math.atan2(y, x);

        // Convert radians back to degrees
        const lat2 = (φ2 * 180) / Math.PI;
        const lon2 = ((λ2 * 180) / Math.PI + 540) % 360 - 180; // Normalize to [-180, +180]

        return { latitude: lat2, longitude: lon2 };
      }

      /**
       * Returns the length of the vector (x, y) from the origin.
       * @param {number} x – x-coordinate
       * @param {number} y – y-coordinate
       * @returns {number} distance from (0,0) to (x,y)
       */
      function calculateVectorDistance(x, y) {
        return Math.sqrt(x * x + y * y);
      }

      function normalizeAngle(angle) {
        return ((angle % 360) + 360) % 360;
      }

      /**
       * Estimate current tide height with sinusoidal easing
       *
       * @param {Date|string|number} lowTime      — time of low tide
       * @param {number}            lowHeight    — height at low tide
       * @param {Date|string|number} highTime     — time of high tide
       * @param {number}            highHeight   — height at high tide
       * @param {Date|string|number} [currentTime=new Date()] — time to estimate
       * @returns {number} smoothly interpolated tide height
       */
      function estimateTideHeightSmooth(lowTime, lowHeight, highTime, highHeight, currentTime = new Date()) {
        // normalize inputs to UTC timestamps
        const tLow = (lowTime instanceof Date ? lowTime : new Date(lowTime)).getTime();
        const tHigh = (highTime instanceof Date ? highTime : new Date(highTime)).getTime();
        const tCurrent = (currentTime instanceof Date ? currentTime : new Date(currentTime)).getTime();

        let t0, h0, t1, h1;

        // console.log('time low: ' + new Date(tLow));
        // console.log('time high: ' + new Date(tHigh));
        // console.log('time current: ' + new Date(tCurrent));
        // console.log(`low height: ${lowHeight}`);
        // console.log(`high height: ${highHeight}`);

        // determine rising vs falling tide
        if (tLow < tHigh) {
          // rising: low → high
          if (tCurrent <= tLow) return lowHeight;
          if (tCurrent >= tHigh) return highHeight;
          t0 = tLow; h0 = lowHeight;
          t1 = tHigh; h1 = highHeight;
        } else {
          // falling: high → low
          if (tCurrent <= tHigh) return highHeight;
          if (tCurrent >= tLow) return lowHeight;
          t0 = tHigh; h0 = highHeight;
          t1 = tLow; h1 = lowHeight;
        }

        // fraction through the tide interval [0…1]
        const frac = (tCurrent - t0) / (t1 - t0);

        // sinusoidal easing: starts slow, speeds up, then slows into the end
        const sineFrac = (1 - Math.cos(Math.PI * frac)) / 2;

        // interpolated height
        const result = h0 + (h1 - h0) * sineFrac;

        // console.log(`currentHeight: ${result}`);

        return result;
      }
    </script>
</body>

</html>